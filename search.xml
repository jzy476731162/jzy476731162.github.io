<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[testText]]></title>
      <url>http://jzy476731162.github.io/2018/04/03/testText/</url>
      <content type="html"><![CDATA[<h1>测试测试</h1>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[创建私有pod库并发布到Cocoapods]]></title>
      <url>http://jzy476731162.github.io/2016/11/03/%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0Cocoapods/</url>
      <content type="html"><![CDATA[<p>老哥们,小弟又来了!哈哈<br>最近工作闲了下来,在等设备安装之后调试,因为觉得好玩闲来无事搞了搞pod,发布了个CJSegmentController </p>
<h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><p>不知道各位对pod的理解是怎样,以前虽然常用Cocoapods,但是其实不太清楚原理。最近探究据我的理解是:pod中的各种三方库是存放在cocoapods管理的一个git项目中,当我们在新设备上安装pod的时候记得要<code>setup</code>一下么?执行<code>pod setup</code>操作后我们会在cocoapods的目录下将pod的远程master分支拉取到本地。默认路径为<code>~/.cocoapods/repos/master</code>。如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/dae4fea2gw1f9fg5p1ajuj219w0ri13d.jpg" alt=""></p>
<p>拿AFN来举例,进入文件夹发现有不同版本的文件夹。每个版本的文件夹对应的是该版本的podspec.json配置文件,来看一下该配置文件里都存储了什么信息:</p>
<p><img src="http://ww4.sinaimg.cn/large/dae4fea2gw1f9fg5okz79j2104100n7g.jpg" alt=""></p>
<p>这基本也就是podspec(即该库该版本的配置信息),上面几条估计大家都能看明白,然后看到<code>&#39;source&#39;</code>这条,what means?? git即为AFN公布的git地址。可以看到在github上。那下面的tag是什么?这里就是至关重要的一点,<code>tag</code>,我想git熟练的老哥们应该知道tag是个啥。tag就是标签嘛。一般在某一产品发布之后在git中打上tag可以便于我们寻找哪个版本app的位置。</p>
<h2 id="打Tag"><a href="#打Tag" class="headerlink" title="打Tag"></a>打Tag</h2><p>切换到当前需要打tag的git节点下,tag命令如下:</p>
<p>git tag -a v1.0.3 -m ‘release version’ <font color="green">//创建一个名为1.0.3的tag(-m为可选)</font></p>
<p>git push –tags        <font color="green">//将tag推到remote</font></p>
<p>然后pod根据配置文件中的这个tag值去你的git source中查找对应版本的三方库。</p>
<p>原理就讲到这里,还有几个重要的标签,我们接下来再讲。</p>
<a id="more"></a>
<h1 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h1><p>重点现在开始了</p>
<p>master是pod的,我们可以fork一份官方的master。但是定制性比较差嘛因为它压根就是为pod服务的。</p>
<p>那么私有仓库的优点就来了:如果你有在项目中很常用的自己写的库或者文件,可以塞进来,其实也就稍微省了那么一丢丢时间,然后项目整洁一些。当然这么做也是有缺点的。万一….你写错代码了呢?会超级麻烦的。</p>
<p>我就直接用了github作为私有仓库,当然如果大家有不想public的库也可以用自己公司的gitlab或者三方的coding,bitBucket等可免费私有的git仓库。</p>
<h2 id="创建空私有库"><a href="#创建空私有库" class="headerlink" title="创建空私有库"></a>创建空私有库</h2><p>先去git上创建一个仓库,就命名为CJSpecs好了。最好不要选择生成readme/gitignore/license文件。等会初始化podspec的时候会产生不必要的merge。就生成一个空仓库好了。</p>
<p>空仓库好了。我们来让pod为我们初始化本地内容:</p>
<p>terminal中执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add [Private Repo Name] [Github HTTPS clone URL]</span><br></pre></td></tr></table></figure>
<p>Private Repo Name为本地私有仓库名称,而后者就是git上的地址啦。这里我的命令是下面这样的:</p>
<font color="green">//pod repo add CJ <a href="https://github.com/jzy476731162/CJSpecs" target="_blank" rel="external">https://github.com/jzy476731162/CJSpecs</a></font>

<p>随后pod在根目录中为我们生成了CJ这个目录,这个目录的git地址是你刚才配置的<code>私有仓库地址(remote repo)</code>。如果记不清后面会迷糊的。之前配置的时候我就没记清这个,饶了好大一个圈子…</p>
<p>生成后是下图这个样子(但是请忽略掉上面两个文件夹。此步骤应该只生成了license和readme)</p>
<p><img src="http://ww3.sinaimg.cn/large/dae4fea2gw1f9fg5opqh9j20yo09umyv.jpg" alt=""></p>
<p>这里步骤不能出问题,有好多博客写的顺序都是乱的。瞎搞….</p>
<h2 id="创建pod"><a href="#创建pod" class="headerlink" title="创建pod"></a>创建pod</h2><p>我是创建了一个CJSegment文件夹。来分辨我到底在干什么…因为本人有时候有点迷糊,搞着搞着名字一样就会晕头转向,我的目标podname是<code>CJSegmentController</code><br>进入CJSegment目录中</p>
<p>terminal中执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create [pod name]</span><br></pre></td></tr></table></figure>
<p>我的命令:</p>
<font color="green">//pod lib create CJSegmentController</font>

<p>我记得当时输入命令后,会提示给你要怎么创建pod</p>
<p>&gt;<br>1.选择使用语言[Swift/ObjC]<br>&gt;<br>2.是否含有Demo[Y/N]<br>&gt;<br>3.好像是view自检..(这个记不太清了)<br>&gt;<br>4.选择test Framework [Specta / Kiwi / None] / (这个也没搞清楚都是什么样式,回头需要查询一下)</p>
<p>随后pod在CJSegment目录下生成了刚才输入的CJSegmentController文件夹,下图</p>
<p><img src="http://ww4.sinaimg.cn/large/dae4fea2gw1f9fg5otq9sj21kw0kigqb.jpg" alt=""></p>
<p>到此pod创建完毕,该进行下一步了</p>
<h2 id="填充pod"><a href="#填充pod" class="headerlink" title="填充pod"></a>填充pod</h2><p>起名一直是编程人员的痛点。就叫填充pod好了。哈哈。</p>
<p>请把您想放入pod中的文件放置到上图的Classes路径下。Assets目录是放置资源文件的地方。</p>
<blockquote>
<p>这里遇到了个坑。我算是中度storyboard拥趸,在我没研究pod私有库之前我认为storyboard是可以放置到pod中的。结果在校验的时候报了bug…提示不能这么干。我说怎么基本上没见到三方pod中还有storyboard的,好吧。只能改代码了…可能是pod为了开发者用起来方便吧。而Storyboard还需要找sb来创建viewController。当然还是有方法使用xib的。</p>
</blockquote>
<p>代码改好也测试完了。塞进去就好了。如果定义了有Demo,请顺便把Demo也完善一下。</p>
<p>然后我们来进行下一步,创建该pod的仓库。</p>
<p>前文提到了pod是根据podSpec文件中的resouce tag来寻找该版本的pod,所以如果想发布到pod上这里用public git。</p>
<p>我去github上创建了一个空git 命名为CJSegmentController,同样没有license/readme原理同上,gitignore可以选填。<br>改好readme文件推到该git上。</p>
<p>git在这里不多说了。如果老哥对git不熟请移步<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖老师的git教程</a>,个人认为廖老师的教程很好,但用好重要还是在于多练。</p>
<p>此时如果到CJ/ 和CJSegmentController/目录下使用<code>git remote -v</code>查看git源发现这两个git地址应该是不一样的。因为前者是私人仓库的地址,后者是你创建的三方库的地址。之前就迷糊在了这里,强行坑了自己半天。</p>
<p>下一步,修改podSpec即pod配置文件,如果老哥使用了xib的话。xib是在资源文件中的。可以扔到Assets中,解注s.resource = “pod/Assets/xx.xib”,也可以放到Classes中。其他的字段也没什么好说的。相信老哥会用pod都明白是什么意思。<code>*.{h,m}</code>是一个类似正则表达式的字符串，表示匹配所有以.h和.m为扩展名的文件。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.source_files  = &quot;CJSegmentController/Classes/**/*.&#123;h,m&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>我的podspec如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/dae4fea2gw1f9fg5p1lsfj21a40zkk8k.jpg" alt=""></p>
<p>至此pod制作相当于完成了。</p>
<h2 id="校验刚做好的pod"><a href="#校验刚做好的pod" class="headerlink" title="校验刚做好的pod"></a>校验刚做好的pod</h2><p>到CJSegmentController的目录下。</p>
<p>Terminal执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --verbose</span><br></pre></td></tr></table></figure>
<p>随后的pod 命令最好是带上–verbose来输出信息。这样可以打印出来详细的错误信息,便于老哥定位错误位置。</p>
<blockquote>
<p>The following build commands failed:<br>CompileStoryboard /Users/CarlJi/Documents/job/CJSegmentController/CJSegmentController/SegmentController.storyboard<br>CompileStoryboard /Users/CarlJi/Documents/job/CJSegmentController/CJSegmentController/SegmentController.storyboard</p>
<ul>
<li>ERROR | license: Sample license type.</li>
<li>ERROR | [iOS] file patterns: The <code>source_files</code> pattern did not match any file.<br> #s.license      = “MIT (example)”<br> s.license      = { :type =&gt; “MIT”, :file =&gt; “LICENSE” }</li>
</ul>
</blockquote>
<p>   这个就是我之前用Storyboard报错,提示没有找到这个SB文件,这就说明podSpec文件中的source那里出了问题,去改吧~~</p>
<p>   如果验证无误就可以进行下一步。 将CJSegmentController push到remote上,<a href="# 打Tag">打好tag</a>。 我设置的tag是0.1.0,你可以按你自己的喜好0.0.1/1.0.0都可以。</p>
<p>   terminal执行校验操作:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint CJSegmentController.podspec</span><br></pre></td></tr></table></figure></p>
<p>   成功后CJ(私人仓库)路径下会出现一个CJSegmentController文件夹(就是我们刚创建的),里面有存储podspec文件,跟master中的形式相同。</p>
<p>   至此私有仓库搭建完成。在podfile中使用cocoapods/master那行的格式来增加私有仓库的git地址即可。</p>
<h1 id="发布到Cocoapods"><a href="#发布到Cocoapods" class="headerlink" title="发布到Cocoapods"></a>发布到Cocoapods</h1><p><a href="http://www.cnblogs.com/wengzilin/p/4742530.html" target="_blank" rel="external">这个发布博客很不错</a></p>
<p>目前cocoapods使用trunk来管理大家pod的发布。</p>
<p>1.注册trunk<br>pod有最低版本限制,如果希望设备上有多版本pod请查看之前的Cocoapods文章安装RVM。</p>
<p>注册trunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register [name] &apos;description&apos; --verbose</span><br></pre></td></tr></table></figure>
<p>name使用Email来代替。命令执行成功后pod 会向邮箱发送一封邮件</p>
<p><img src="http://ww2.sinaimg.cn/large/dae4fea2gw1f9fg5oul8jj20qy09swgt.jpg" alt=""></p>
<p>点击链接即可完成注册流程。</p>
<p>terminal执行如下查询自己的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/dae4fea2gw1f9fg5oq6rqj20vc0aidhz.jpg" alt=""></p>
<p>当然，如果你的pod是由多人维护的，你也可以添加其他维护者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk add-owner CJSegmentController xx@xx.com</span><br></pre></td></tr></table></figure>
<p>至此步-Pods:应该是空的…这里我是后截的图。</p>
<p>通过trunk上传podspec文件</p>
<p>进入之前校验生成的pod目录中 : CJSegmentController目录下生成的0.1.0文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push CJSegmentController.podspec</span><br></pre></td></tr></table></figure>
<p>该命令执行了如下操作:</p>
<ul>
<li><p>验证你的podspec文件是否合法。在trunk方式之前我们一般用“pod lib lint”命令进行验证。</p>
</li>
<li><p>上传podspec文件到trunk服务器(其实最终也会自动添加到<a href="https://github.com/CocoaPods/Specs中，只是使用trunk方式省去了以前先fork在pull" target="_blank" rel="external">https://github.com/CocoaPods/Specs中，只是使用trunk方式省去了以前先fork在pull</a> request的繁琐操作)</p>
</li>
<li><p>将你上传的podspec文件转成json格式文件。</p>
</li>
</ul>
<p>因为上传成功会自动为你更新本地master库,等待一会就完成了。<br><img src="http://ww2.sinaimg.cn/large/dae4fea2gw1f9fg5om2ozj21c610itl5.jpg" alt=""></p>
<p>告诉你的朋友吧!</p>
<p>如果要更新你的pod版本.需要到pod路径下更改代码,修改git的tag值并且在podspec中做出对应修改,然后校验,trunk push。</p>
<blockquote>
<p><a href="https://github.com/jzy476731162/CJSegmentController" target="_blank" rel="external">CJSegmentController地址</a><br>是一个ContainerSegmentViewController,解决了不同子ViewController上拥有不同的barButtonItem状态但显示在parentVC的navigationBar上异常的问题。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode添加多个Target]]></title>
      <url>http://jzy476731162.github.io/2016/11/02/Xcode%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AATarget/</url>
      <content type="html"><![CDATA[<h3 id="Target概念"><a href="#Target概念" class="headerlink" title="Target概念"></a>Target概念</h3><p>Target 是用来指定一个需要构建(build)的产品,其中包含了从project或workspace中的一系列文件在构建时的信息。Target定义了一个简单的产品;它将输入信息打包进编译系统(包含构建中必须的源文件和处理源文件的说明)。项目(Project)中可以包含一个或者多个Target,每一个都可以产生一个产品。</p>
<p>构建产品的说明是以构建信息(build settings)和构建阶段(build phases)组成,你可以在Xcode项目编辑器(product editor)中编辑这些说明。Target继承项目的构建设置(build settings),但是你可以通过在不同的target level指定不同的设置信息来重载它。(其实也可以在All中也可以自行修改。对应的在Level中系统会进行更新,如图-1)。同时只能存在一个可用的target;Xcode scheme来指定哪一个是可用的。</p>
<p><img src="http://ww3.sinaimg.cn/large/dae4fea2gw1f9e1z1i0gpj20zc09wwhs.jpg" alt="图1"></p>
<p>target和它的产品可以跟另一个target关联。如果一个target进行构建时需要另一个target的输出作为输入信息,前者依赖后者。如果他们都是在同一个workspace,Xcode可以发现依赖关系,并按顺序来构建产品。这种关系成为隐性依赖(implicit dependency)。你也可以在构建设置(build settings)中指定依赖关系,并且指定两个实际上没有依赖关系的target成为隐性依赖关系。举个例子,你可能在同一个workspace中创建一个library和一个需要链接该library的application。Xcode可以发现这个关系,并且首先构建library。然而你想链接本workspace之外的library,你需要在构建设置(build settings)中创建一个显性依赖来重载这个隐性依赖。</p>
<a id="more"></a>
<blockquote>
<p>优点:可以在一个项目中配置两个版本。减少切换环境的工作量。</p>
</blockquote>
<h3 id="创建一个新的Target"><a href="#创建一个新的Target" class="headerlink" title="创建一个新的Target"></a>创建一个新的Target</h3><p>进入项目设置,右击当前的target,选择Duplicate<br><img src="http://ww3.sinaimg.cn/large/dae4fea2gw1f9e1zq1xpkj21kw0xj13l.jpg" alt="图2"></p>
<p><img src="http://ww2.sinaimg.cn/large/dae4fea2gw1f9e200hw3nj20us0gpjwa.jpg" alt="图3"><br>此时生成一个名为xxcopy的target。</p>
<hr>
<h3 id="配置Dev-Target"><a href="#配置Dev-Target" class="headerlink" title="配置Dev Target"></a>配置Dev Target</h3><p>双击更改新Target名字。</p>
<p>但是scheme的名字是通过点击设备左边的scheme-&gt;manage schemes,双击修改scheme名称,如下图<br><img src="http://ww3.sinaimg.cn/large/dae4fea2gw1f9e20pn4moj21kw0sjqaz.jpg" alt="图8"></p>
<p>注意左边目录会生成一个targetTest copy-Info.plist。<br>为了便于管理,进入该info.plist路径。将它移动到和Info.plist同级目录下,顺便给他改个名字加到工程目录中。我这里改成了devInfo.plist。</p>
<p>此时DevTarget一定会出问题。。。因为Info.plist路径变了</p>
<p>来到DevTarget构建设置(build settings)里搜索info.plist,并更改plist路径即可<br><img src="http://ww1.sinaimg.cn/large/dae4fea2gw1f9e209zw0aj20xg0intdp.jpg" alt="图4"></p>
<h4 id="定义宏来配置代码中环境切换"><a href="#定义宏来配置代码中环境切换" class="headerlink" title="定义宏来配置代码中环境切换"></a>定义宏来配置代码中环境切换</h4><p>本图是开启level窗口试图。更直观的看出继承关系一些。在构建设置中搜索<code>preprocessorMacro</code>,将DevTarget增加Dev=1,将原target增加Dev=0,反正这里的宏是由你自己定义的,只要代码中做出对应修改就可以了。<br>对于Objective-C的项目，拓展<code>Preprocessor Macros</code>在Rebug和Release区域添加一个变量。对于开发target（即testDev），将该值设置为<code>DEVELOPMENT = 1</code>。另一个，将值设为<code>DEVELOPMENT=0</code>来表示生产版本。<br><img src="http://ww2.sinaimg.cn/large/dae4fea2gw1f9e20pa5dwj20ut0k8n1d.jpg" alt="图5"><br>对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。选中开发target，添加一个标识表示开发版本。找到<code>Build Setting</code>往下滚动到<code>Swift Compiler - Custom Flags</code>部分。将值设为<code>-DDEVELOPMENT</code>表示这个target作为开发版本。<br><img src="http://cc.cocimg.com/api/uploads/20160330/1459309199528760.png" alt="图9"></p>
<p>刚才我在代码中配置好了环境切换开关,现在来试一下<br><img src="http://ww4.sinaimg.cn/large/dae4fea2gw1f9e20peglxj20za0mz0y5.jpg" alt="图6"><br><img src="http://ww3.sinaimg.cn/large/dae4fea2gw1f9e20p8jyuj20xg0mtn2w.jpg" alt="图7"><br>OK!完工了</p>
<hr>
<blockquote>
<p>Tips:<br>在使用Git时,如果是在除主干分支的其他分支上创建的多Target而没有merge到主干分支上。当删除掉该git重新clone一份切换到之前创建target的分支上。你会发现之前设置的scheme消失了,但target仍然存在,记得重新添加一下scheme就可以了。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods的安装以及多版本Pods共存]]></title>
      <url>http://jzy476731162.github.io/2016/07/01/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%89%88%E6%9C%ACPods%E5%85%B1%E5%AD%98/</url>
      <content type="html"><![CDATA[<!--[TOC]-->
<hr>
<h2 id="CocoaPods的定义"><a href="#CocoaPods的定义" class="headerlink" title="CocoaPods的定义"></a>CocoaPods的定义</h2><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit,AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。<br>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。<br>在Mac上默认已经为我们配置好了Ruby环境,所以Mac用户基本可以直接跳过Ruby环境配置.如果Ruby有问题<a href="#安装Ruby">请链接到这里</a><br><a id="more"></a></p>
<hr>
<h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>在终端(Terminal)中查看Ruby镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gem source</span><br><span class="line"></span><br><span class="line">//如果显示如下源那么说明镜像配置OK了可以跳过此步骤</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果显示如下,那么就接着做吧.</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>如果不是本镜像源那么需要将它改成淘宝的镜像源.否则会在install,update等情况下因为拿不到资源卡住,TC你懂得.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//移除原镜像源</span><br><span class="line">$ gem source --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line">//换淘宝镜像源(记得是https)</span><br><span class="line">$ gem source -a https://ruby.taobao.org/ </span><br><span class="line"></span><br><span class="line">//随后查看是否配置成功,恩,结果在上面...</span><br><span class="line">$ gem source</span><br></pre></td></tr></table></figure></p>
<p>随后就是安装了,输入后等待安装完毕即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods (使用最新)</span><br><span class="line">或</span><br><span class="line">$ sudo gem install cocoapods -v 0.38/1.0.0 (指定版本)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="CocoaPods的简单使用"><a href="#CocoaPods的简单使用" class="headerlink" title="CocoaPods的简单使用"></a>CocoaPods的简单使用</h2><h3 id="利用CocoaPods在项目中导入AFN类库"><a href="#利用CocoaPods在项目中导入AFN类库" class="headerlink" title="利用CocoaPods在项目中导入AFN类库"></a>利用CocoaPods在项目中导入AFN类库</h3><p>为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure>
<p>过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-&gt; AFNetworking (3.1.0)</span><br><span class="line">A delightful iOS and OS X networking framework.</span><br><span class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</span><br><span class="line">- Homepage: https://github.com/AFNetworking/AFNetworking</span><br><span class="line">- Source:   https://github.com/AFNetworking/AFNetworking.git</span><br><span class="line">- Versions: 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3,</span><br><span class="line">3.0.0-beta.2, 3.0.0-beta.1, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2,</span><br><span class="line">2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0,</span><br><span class="line">2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4,</span><br><span class="line">1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2,</span><br><span class="line">1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo]</span><br><span class="line">- Subspecs:</span><br><span class="line">- AFNetworking/Serialization (3.1.0)</span><br><span class="line">- AFNetworking/Security (3.1.0)</span><br><span class="line">- AFNetworking/Reachability (3.1.0)</span><br><span class="line">- AFNetworking/NSURLSession (3.1.0)</span><br><span class="line">- AFNetworking/UIKit (3.1.0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt; AFNetworking+AutoRetry (0.0.5)</span><br><span class="line">Auto Retries for AFNetworking requests</span><br><span class="line">pod &apos;AFNetworking+AutoRetry&apos;, &apos;~&gt; 0.0.5&apos;</span><br><span class="line">- Homepage: https://github.com/shaioz/AFNetworking-AutoRetry</span><br><span class="line">- Source:   https://github.com/shaioz/AFNetworking-AutoRetry.git</span><br><span class="line">- Versions: 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1 [master repo]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt; AFNetworking+Ext (1.2.1)</span><br><span class="line">AFNetworking的封装, 并提供一个 UIImageView+DYLoading  cache in fileSystem+memory</span><br><span class="line">pod &apos;AFNetworking+Ext&apos;, &apos;~&gt; 1.2.1&apos;</span><br><span class="line">- Homepage: https://github.com/junhaiyang/AFNetworkingExt</span><br><span class="line">- Source:   https://github.com/junhaiyang/AFNetworkingExt.git</span><br><span class="line">- Versions: 1.2.1, 1.2, 1.1, 1.0, 0.5, 0.4, 0.3 [master repo]</span><br><span class="line">- Subspecs:</span><br><span class="line">- AFNetworking+Ext/Base (1.2.1)</span><br><span class="line">- AFNetworking+Ext/AFCustomRequestOperation (1.2.1)</span><br><span class="line">- AFNetworking+Ext/AFDownloadRequestOperation (1.2.1)</span><br><span class="line">- AFNetworking+Ext/AFTextResponseSerializer (1.2.1)</span><br><span class="line">- AFNetworking+Ext/example (1.2.1)</span><br><span class="line">- AFNetworking+Ext/UIKit (1.2.1)</span><br><span class="line">- AFNetworking+Ext/UIKit/UIImageView+DYLoading (1.2.1)</span><br></pre></td></tr></table></figure>
<p>会返回最新的版本内容,这样就可以确定AFNetworking是支持cocoapods的.<br>好吧，废话少说，我们先创建这个神奇的PodFile。在terminal中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile或者命令行<code>pod init</code>(推荐)，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Podfile</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在pod 1.0.0以下版本,Podfile是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform : ios, &apos;7.1&apos;  </span><br><span class="line">pod &apos;AFNetworking&apos;</span><br></pre></td></tr></table></figure></p>
<p>而在 1.0.0以上版本由于pod更新,使用旧方法的pod在安装和更新的时候会报错:<br><code>The dependency</code>xx<code>is not used in any concrete target.</code><br>写法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//XX是你的target名称</span><br><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &apos;XX&apos; do</span><br><span class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这部分我觉得有必要再开一片文章单独写这个…所以简单的就是这样就可以了<br>这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 8.0, 要下载的AFNetworking版本是2.6(当然也可以换成<code>pod &#39;AFNetworking&#39; 然后换行</code>,此时会使用最新的版本)。<br>然后保存退出。vim环境下，在输入上述文字之后按Esc键,输入保存退出命令：<code>:wq</code></p>
<p>在当前目录下,运行如下命令安装三方库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure></p>
<p>如果没有错误的话终端会出现下列信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing AFNetworking (2.0.2)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] From now on use `CocoaPodsDemo.xcworkspace`.</span><br></pre></td></tr></table></figure></p>
<p>随后使用CocoaPodsDemo.xcworkspace打开项目,而不是打开.xcodeproj<br>这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”</p>
<hr>
<h2 id="多版本Pod共存"><a href="#多版本Pod共存" class="headerlink" title="多版本Pod共存"></a>多版本Pod共存</h2><p>首先要下载个<code>RVM(Ruby Version Manager)</code>,可以切换Ruby环境,安装多个版本Ruby.<br>因为Mac默认是配置好Ruby环境的,在终端输入<code>gem environment</code>查看Ruby环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RubyGems Environment:</span><br><span class="line">- RUBYGEMS VERSION: 2.0.14.1</span><br><span class="line">- RUBY VERSION: 2.0.0 (2015-12-16 patchlevel 648) [universal.x86_64-darwin15]</span><br><span class="line">- INSTALLATION DIRECTORY: /Library/Ruby/Gems/2.0.0</span><br><span class="line">- RUBY EXECUTABLE: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby</span><br><span class="line">- EXECUTABLE DIRECTORY: /usr/local/bin</span><br><span class="line">- RUBYGEMS PLATFORMS:</span><br><span class="line">- ruby</span><br><span class="line">- universal-darwin-15</span><br><span class="line">- GEM PATHS:</span><br><span class="line">- /Library/Ruby/Gems/2.0.0          (默认本地的)</span><br><span class="line">- /Users/CarlJi/.gem/ruby/2.0.0     (HomeBrew安装的)</span><br><span class="line">- /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0</span><br><span class="line">- GEM CONFIGURATION:</span><br><span class="line">- :update_sources =&gt; true</span><br><span class="line">- :verbose =&gt; true</span><br><span class="line">- :backtrace =&gt; false</span><br><span class="line">- :bulk_threshold =&gt; 1000</span><br><span class="line">- :sources =&gt; [&quot;https://ruby.taobao.org/&quot;]</span><br><span class="line">- REMOTE SOURCES:</span><br><span class="line">- https://ruby.taobao.org/</span><br></pre></td></tr></table></figure></p>
<h3 id="安装RVM"><a href="#安装RVM" class="headerlink" title="安装RVM"></a>安装RVM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可能需要翻墙</span><br><span class="line">$ curl -L get.rvm.io | bash -s stable</span><br><span class="line">// 要想使用 &apos;rvm&apos;命令需要执行下面一行代码</span><br><span class="line">$ source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure>
<h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 列出可安装的ruby版本信息</span><br><span class="line">rvm list known</span><br><span class="line">// 安装一个ruby版本</span><br><span class="line">rvm install 2.3</span><br><span class="line">// 如果想设置为默认版本，可以用这条命令来完成</span><br><span class="line">rvm use 2.3 --default </span><br><span class="line"></span><br><span class="line">// 可选:</span><br><span class="line">// 查看已安装的ruby</span><br><span class="line">rvm list</span><br><span class="line">// 卸载已安装ruby版本</span><br><span class="line">rvm remove 2.3</span><br></pre></td></tr></table></figure>
<h3 id="切换Ruby版本"><a href="#切换Ruby版本" class="headerlink" title="切换Ruby版本"></a>切换Ruby版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面的安装步骤完成之后，就可以通过 rvm 来切换 ruby 版本了：</span><br><span class="line">rvm use system # 使用系统 ruby</span><br><span class="line">rvm use 2.3  # 使用 rvm ruby</span><br><span class="line">在切换 ruby 版本之后，gem 也会跟着切换，我们就可以安装两个版本的 CocoaPods 了。</span><br></pre></td></tr></table></figure>
<h3 id="安装Pods"><a href="#安装Pods" class="headerlink" title="安装Pods"></a>安装Pods</h3><p>回到 <a href="#安装CocoaPods">安装CocoaPods</a></p>
<blockquote>
<p>注意事项<br>如果想安装0.39等低级版本请使用Ruby2.2版本.Ruby2.1版本安装不上Pods,而2.3版本安装低版本Pods可以成功但是最后在<code>pod install</code>或 <code>pod update</code>出现问题.</p>
</blockquote>
<hr>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><h3 id="Tips-参数"><a href="#Tips-参数" class="headerlink" title="Tips : 参数"></a>Tips : 参数</h3><p>目前我比较常用的参数是<code>--verbose</code>和<code>--no-repo-update</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod install --verbose --no-repo-update </span><br><span class="line">或</span><br><span class="line">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure></p>
<p><code>verbose</code> : 打印信息<br><code>no-repo-update</code> : 这是更新本地的pod仓库，和Git一样，本地有个pod repo，和github上的版本对应，如果你不想更新这个的话后面加上–no-repo-update就可以了，但是这样会有个问题，如果github上pods的一些插件像AF有新版本了，你本地搜索的af还是旧版本如果用的新版本号是无法装配的，所以每隔一段时间应执行一下<code>pod repo update</code></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="‘xx’头文件找不到"><a href="#‘xx’头文件找不到" class="headerlink" title="‘xx’头文件找不到."></a>‘xx’头文件找不到.</h4><p>target -&gt; build settings -&gt; User Header Search Paths 输入主目录<code>$(SRCROOT)</code>或新增一个值<code>$(PODS_ROOT)</code>,右边选中recursive.这样Xcode就会在项目目录中递归搜索文件.</p>
<h4 id="在Github或Code4App上下载源码解码后报错缺少头文件"><a href="#在Github或Code4App上下载源码解码后报错缺少头文件" class="headerlink" title="在Github或Code4App上下载源码解码后报错缺少头文件."></a>在Github或Code4App上下载源码解码后报错缺少头文件.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure>
<p>之后就可以编译运行</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS8 TableView 自动算高]]></title>
      <url>http://jzy476731162.github.io/2016/06/15/iOS8-TableView-%E8%87%AA%E5%8A%A8%E7%AE%97%E9%AB%98/</url>
      <content type="html"><![CDATA[<p>在iOS8及以上系统中,可以使用AutoLayout来设置cell，使得内容 撑起 Cell,而只需要将tableView的<code>rowHeight</code>属性设置为<code>UITableViewAutomaticDimension</code> 自动计算，然后使用</p>
<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath {
return 50;
}
</code></pre><a id="more"></a>
<p>来设置一个估算的大致高度。</p>
<p>结果在最下</p>
<p>但我还是更习惯将行高缓存下来:<br>如果上面提到的你都做了，但是tableView:heightForRowAtIndexPath:的性能仍然慢的不可接受。非常不幸，你需要给行高做一些缓存（这是苹果的工程师们给出的改进建议）。大体的思路是，第一次计算时让自动布局引擎解析约束条件，然后将计算出的行高缓存起来，以后所有对该cell的高度的请求都返回缓存值。当然，关键还要确保任何会导致cell高度变化的情况发生时你都清除了缓存的行高——这通常发生在cell的内容变化时或其他重大事件发生时（比如用户调节了动态类型文本大小(Dynamic Type text size)的滑动条）。</p>
<p><img src="http://ww4.sinaimg.cn/large/dae4fea2gw1f4w1m7g5z5j20pu17cqab.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS绘图思想]]></title>
      <url>http://jzy476731162.github.io/2016/06/02/iOS%E7%BB%98%E5%9B%BE%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html" target="_blank" rel="external">原文链接</a><br><!--[TOC]--></p>
<h2 id="iOS绘图思想"><a href="#iOS绘图思想" class="headerlink" title="iOS绘图思想"></a>iOS绘图思想</h2><p>高质量图像是应用UI中重要的一部分，提供高质量图像不仅会让应用看起来更棒，还会使它看起来像原生系统的扩展。iOS系统提供两种基础的方式来创建高质量图像：<code>openGL</code>或<code>原生渲染(Quartz，Core Animation，UIkit)</code>。本文描述的是用原生渲染(如果您想学习OpenGL绘图，<a href="https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793" target="_blank" rel="external">请看链接</a>)</p>
<p>Quartz是主要的绘画接口，提供支持如：基于路径的绘图，抗锯齿渲染，渐变填充图案，图片，颜色，坐标空间变换，以及PDF创建、显示、解析。UIKit提供了通过OC封装的文字艺术(line art)，Quartz 图片以及颜色处理。Core Animation为UIKit中view的property的基础动画变换提供了底层支持并且可以用来实现自定义动画。</p>
<p>本章节提供了iOS应用绘画的过程概述，伴随着每一种绘画技术都会有特定的绘画技巧。你将找到在iOS平台上优化绘画代码的提示和指导。</p>
<blockquote>
<p>不是所有的UIkit类都是线程安全的。在主线程外的其他线程中执行绘画操作时请先检查文档。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="UIKit-图像系统"><a href="#UIKit-图像系统" class="headerlink" title="UIKit 图像系统"></a>UIKit 图像系统</h3><p>在iOS中，所有在屏幕上绘画出来的-不管是通过OpenGL，Quartz，UIKit还是Core Animation - 都是在UIView的一个实例或子类范围中操作。Views决定了在屏幕上绘制发生的部位。如果你使用系统提供的views，系统会为你自动绘制。如果你定义的是自定义views，你必须自己提供绘制的代码。如果使用Quartz，Core Animation，UIkit去绘制，你将会用到在接下来的章节中描述的绘图思想。</p>
<p>除了立刻在屏幕上绘制，UIKit也允许你画到离屏的位图或者PDF图形的上下文中。当你在离屏上下文中绘制时，不是在一个view中绘制，也意味着在view的绘图周期中是不推荐这么做的(除非你随后取出图像并且在imageView或相似空间中绘制出来)。</p>
<h4 id="View绘图循环"><a href="#View绘图循环" class="headerlink" title="View绘图循环"></a>View绘图循环</h4><p>子类化的UIView的基础绘画模式是在必要时更新内容。UIView类使得更新过程更加简单有效：通过收集你发出的更新请求并将它们在合适的时机传输到你的绘制代码中。</p>
<p>当一个view第一次被展示出来或者view的一部分需要被重新绘制，iOS通过调用view的<strong><code>drawRect:</code></strong>方法让view绘制它的内容。还有很多行为可以触发view的更新：</p>
<blockquote>
<ul>
<li>移动或移除一个正在遮挡view的另一个view</li>
<li>通过设置一个view的<code>hidden</code>为No来使得先前隐藏的view可见</li>
<li>将一个view从屏幕中划出后划入屏幕</li>
<li>立刻调用view的方法：<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code></li>
</ul>
</blockquote>
<p>系统views是自动重绘的。对于自定义views来说，必须重载<code>drawRect:</code>方法并在其中执行绘制代码。在<code>drawRect：</code>方法中，使用原生绘制技术来绘画图形，文本，图像，渐变或其他你想要的视觉内容。你的view第一次变得可见时，iOS将一个矩形传入view的<code>drawRect:</code>方法，这个矩形包含了view的整个可见区域。在随后的调用中，这个矩形只包括需要重绘的区域。为了使性能最大化，你应该仅重绘受影响的区域。</p>
<p>在调用<code>drawRect:</code>之后，view将自己标记成<code>已更新(updated)</code>并且等待新操作来临以及触发另外一个更新循环。如果view展示的是静态内容，在由滑动和其它views的存在导致你的view的能见变化时，你唯一需要做的就是响应这些变化。</p>
<p>如果你想改变view的内容，必须通知view去重绘内容。调用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInrect:</code>来触发一个更新。举个栗子，如果一秒内需要多次更新内容，你可能会想创建一个定时器来刷新view。也可以在响应用户操作或在view中创建新内容来更新view。</p>
<blockquote>
<p>不要手动调用<code>drawRect：</code>，该方法<strong><em>仅</em></strong>应在iOS屏幕重绘期间通过代码创建。在其他情况下，图形上下文不存在，所以也不可能绘制（图像上下文会在下一章节中解释）</p>
</blockquote>
<p>####iOS中的坐标系统以及绘制<br>当一个应用在iOS中绘制时，它必须在定义为坐标系统的二维空间内定位出绘制的内容位置。这个概念在第一眼看到时会觉得很直观，但事实上却很麻烦。iOS应用在绘制时有时需要应对不同的坐标系。</p>
<p>在iOS中，所有的绘制都在图形上下文中完成。从概念上讲，图形上下文是一个描述<code>哪里</code>、以及<code>怎么</code>绘制的对象，包含基础的绘制属性，例如绘制中使用的颜色，裁剪区域，线条宽度和样式信息，字体信息，合成选项等等。</p>
<p>此外，如图1-1中所示，每一个图形上下文都有一个坐标系。更确切的说，每一个图形上下文有三个坐标系：</p>
<blockquote>
<ul>
<li><code>绘图坐标系(用户)</code>。该坐标系是用于绘图任务的执行。</li>
<li><code>view坐标系(基础空间)</code>。该坐标系是与view相关的固定的坐标系。</li>
<li><code>设备坐标系(物理)</code>。该坐标系代表屋里屏幕上的像素。</li>
</ul>
</blockquote>
<p><img src="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/coordinate_differences_2x.png" alt="图1-1 绘图坐标，view坐标，硬件坐标的关系"></p>
<p>iOS绘图框架可以创建一系列绘制的具体目标的上下文 - 屏幕，位图，PDF内容等等 - 并且这些图形上下文为该目标建立了具体的初始坐标系统。这个初始坐标系统被称作<code>默认坐标系</code>，它是1：1映射到view底层坐标系统的。</p>
<p>每一个view拥有一个<code>当前变换矩阵(current transformation matrix(CTM))</code>，是一个数学矩阵，将当前绘制坐标系中的点映射到(固定的)<code>view坐标系</code>中。应用可以更改这个矩阵来改变接下来绘制操作的表现。</p>
<p>每一个iOS绘制框架都会在当前图形上下文中建立一个<code>默认坐标系</code>。在iOS中，有两种主要的坐标系统：</p>
<blockquote>
<ul>
<li>左上原点坐标系(upper-left-origin(ULO))，绘制操作的原点在绘制区域的左上角，向下和向右都是正值。用于UIKit和Core Animation的<code>默认坐标系</code>是基于ULO的。</li>
<li>左下原点坐标系(lower-left-origin(LLO))，绘制操作的原点在绘制区域的左下角，向上和向右都是正值。用于Core Graphics框架的<code>默认坐标系</code>是基于LLO的。</li>
</ul>
</blockquote>
<p><img src="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/flipped_coordinates-2_2x.png" alt="iOS中的默认坐标系"></p>
<blockquote>
<p>OS X中的<code>默认坐标系</code>是基于LLO的。尽管Core Graphics以及AppKit框架的绘制方式和方法都完美适用于该坐标系，AppKit为左上角坐标系提供翻转坐标系的程序支持。</p>
</blockquote>
<p>在调用<code>drawRect：</code>之前，UIkit为绘图操作建立了<code>默认坐标系</code>，(本句原文:UIKit establishes the default coordinate system for drawing to the screen by making a graphics context available for drawing operations)。在<code>drawRect：</code>中，应用可以设置图形状态参数(例如填充的颜色)以及在不需要明确指出图形上下文的前提下在当前的图形上下文中绘制。这种隐式的图形上下文建立了一个<code>ULO默认坐标系</code></p>
<h4 id="点与像素"><a href="#点与像素" class="headerlink" title="点与像素"></a>点与像素</h4><p>在iOS中 在绘图代码中你指定的坐标系和实际底层设备的像素点是不同的。当使用原生绘图技术例如Quartz，UIKit，Core Animation，绘制坐标空间和view的坐标空间都是逻辑坐标空间。以points作为衡量单位。这些逻辑坐标系是在设备坐标空间使用系统框架在屏幕上管理pixels来解耦出来的。</p>
<p>系统自动的将view坐标空间的point映射为设备坐标空间的pixels，但不总是一对一的映射。这种特性引出了一个你需要记住的重要事实：</p>
<blockquote>
<p><strong>point不一定与pixel相同</strong></p>
</blockquote>
<p>使用points的目的是在无关设备间提供一个相同尺寸的输出。在大多数情况下，point的实际尺寸是不相干的。使用point的目的是提供一个相对一致的尺寸，你可以在代码中指定view的尺寸和位置并且渲染内容。point与pixel的映射方式实际是由系统框架处理的。举个栗子，在高分辨率屏幕的设备上，一个一point宽的线实际是两个pixel那么宽。结果就是如果你在两个相似的设备上绘制相同的内容，其中一个是高质量屏幕，在这两个设备上看到的内容看起来尺寸相同。</p>
<blockquote>
<p>在PDF渲染和打印的上下文中，Core Graphics定义了<code>point</code> 是使用工业标准映射一英尺的1/72。</p>
</blockquote>
<p>在iOS中，UIScreen，UIVew，UIImage，CALayer提供property来获取(或设置)缩放因子(scale factor)，缩放因子是描述point和pixel之间关系的一个特定对象。例如，每一个UIkit view有<code>contentScaleFactor</code>属性变量。在标准分辨率屏幕上，缩放因子一般为1.0.而在高分辨率屏幕上，缩放因子一般为2.0。在将来可能会出现其它缩放因子。(在iOS4以上，缩放因子应该被认作1.0)。</p>
<p>原生绘图技术，例如Core Graphics，考虑一下当前的缩放因子。例如，如果一个view实现了<code>drawRect:</code>方法，UIKit自动将view的缩放因子设置为屏幕的缩放因子。另外 UIKit通过考虑缩放因子画图可以自动修复图形上下文的<code>当前变换矩阵</code>。在<code>drawRect:</code>中绘制的内容会根据底层设备屏幕来适当的缩放。</p>
<p>由于自动映射，当写绘制的代码时，通常不必关注pixel。然而有些时候你需要根据point与pixel映射规则来改变应用的绘制行为-在高分辨率屏幕下载高质量图片或在低分辨率屏幕上绘制时避免异常的缩放。</p>
<p>在iOS中，当你在屏幕上绘制事物时，图像子系统使用一种抗锯齿技术将高质量图片显示在低分辨率屏幕上。最好的解释就是举例。当你在纯白色背景下绘制一条黑色竖线，如果线条正好落在1px上，你会看到在白色区域出现一系列黑色像素点。如果它在两个px之间展示，看起来就是两个紧邻的灰色像素，如下图所示。</p>
<p><center>(右边的称为whole-numbered point)</center><br><img src="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/pixel_alignment_2x.png" alt=""></p>
<p>位置是由whole-numbered points在pixels中点决定的。距离，如果你从(1.0,1.0)到(1.0,10.0)画了一条1px宽的竖线，会得到一条模糊的灰线。如果你绘制了一条2px宽的线，会得到一条纯黑线，因为它完全的覆盖了2个px。一般来说，以px为单位，奇数为值 的宽度的线条看起来比偶数值px的线条更柔和，除非你调整他们的位置使线条与pixel格子重合。</p>
<p>比例因子的作用就是决定1point宽的线条覆盖了几个pixel。</p>
<p>在低分辨率的情况下(1.0缩放因子)，宽度 ： 1 point 线条= 1 pixel 线条。在画1point宽的线条时为了避免抗锯齿，除非是偶数pixels宽，否则你必须将位置向任一边偏移0.5point。如果线条是偶数points宽，为了避免模糊的线条一定不要这么做。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/regular_vs_retina_2x.png" alt=""></p>
<p>在高分辨率情况下(缩放因子2.0)，1point宽的线条是不会产生抗锯齿情况，因为它占满了两个px格子(-0.5~+0.5)。如果想绘制1pixel的线条，将宽度设置为0.5points 并且偏移量设为0.25，对照如上图所示。</p>
<p>当然，改变基于缩放因子的绘图特性可能会导致悲剧。1px宽的线条在某些设备上看起来完美但是在高分辨率设备上可能会太细导致无法看清。决定权在你手上！</p>
<hr>
<h3 id="获取图像上下文"><a href="#获取图像上下文" class="headerlink" title="获取图像上下文"></a>获取图像上下文</h3><p>大多情况下，图形上下文已经为你配置好。每一个view对象会在<code>drawRect:</code>被调用时自动创建图形上下文来使你的代码立即绘制自定义的内容。作为配置的一部分，UIView的底层为当前绘制环境创建图形上下文(一个<code>CGContextRef</code>不透明的类型)<br>如果你想在view外绘制东西(例如在位图或PDF中捕获一系列绘制操作),如果调用Core Graphics方法是需要一个上下文对象的，你必须进行额外的步骤来获取上下文对象。以下部分解释了原因。</p>
<p>更多关于图形上下文，修改<code>图像状态(graphics state)</code>信息以及使用图形上下文来创建自定义内容，查看<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="external">Quartz 2D Programming Guide</a>。关于图形上下文的一系列函数请参考这里<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_blank" rel="external">CGContext Reference</a>,<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGBitmapContext/index.html#//apple_ref/doc/uid/TP30000947" target="_blank" rel="external">CGBitmapContext Reference</a>,<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPDFContext/index.html#//apple_ref/doc/uid/TP30000957" target="_blank" rel="external">CGPDFContext Reference</a>.</p>
<h4 id="向屏幕上绘制"><a href="#向屏幕上绘制" class="headerlink" title="向屏幕上绘制"></a>向屏幕上绘制</h4><p>如果使用Core Graphics函数绘制view，无论在<code>drawRect:</code>方法或者别的地方，前提是需要一个图形上下文(大多数这些方法的第一个参数一定是<code>CGContectRef</code>对象)。你可以调用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIGraphicsGetCurrentContext" target="_blank" rel="external"><code>UIGraphicsGetCurrentContext</code></a>取得与在<code>drawRect:</code>中隐式创建的同一个上下文。由于是同一个图形上下文，绘制函数应该参考<code>ULO默认坐标系</code></p>
<p>如果想使用Core Graphics函数在UIKit的view中绘制，应该使用<code>ULO默认坐标系</code>来进行绘图操作。此外，你可以将<code>当前变换矩阵</code>翻转并且在UIKit的view中使用CoreGraphics原生的<code>LLO坐标系</code>进行绘制。<a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW26" target="_blank" rel="external">Flipping the Default Coordinate System</a>中讨论了翻转的详情。</p>
<p><code>UIGraphicsGetCurrentContext</code>方法总是会返回一个当前有效的图形上下文。比如，如果你创建了一个PDF上下文并且调用了<code>UIGraphicsGetCurrentContext</code>，可以接收到一个PDF上下文。如果想使用CoreGraphics方法来在view上绘制就必须使用<code>UIGraphicsGetCurrentContext</code>返回的图形上下文。</p>
<blockquote>
<p><code>UIPrintPageRenderer</code>类声明了绘制可印刷内容的方法。在一个类似于<code>drawRect:</code>方法中，UIKit在这些方法的实现中设置了隐式的图形上下文。这个图形上下文建立了一个<code>ULO默认坐标系</code></p>
</blockquote>
<h4 id="绘制位图上下文和PDF上下文"><a href="#绘制位图上下文和PDF上下文" class="headerlink" title="绘制位图上下文和PDF上下文"></a>绘制位图上下文和PDF上下文</h4><p>UIKit提供了以下行为的方法：在位图图形上下文渲染图片，通过在PDF图形上下文中绘制产生PDF内容。调用这些方法的第一步都是创建一个图形上下文-分别是一个位图上下文或者PDF上下文。返回的对象作为当前(以及隐式)图形上下文进行连续的绘制和状态设置。当完成在上下文中的绘制，调用另外一个方法来关闭上下文。</p>
<p>UIKit的位图上下文和PDF上下文都建立了一个<code>ULO默认坐标系</code>。CoreGraphics也有对应的方法来在位图上下文中渲染和在PDF图形上下文中绘制。通过CoreGraphics创建的上下文是基于<code>LLO默认坐标系的</code>。</p>
<blockquote>
<p>在iOS中，建议你使用UIKit框架来绘制位图上下文和PDF上下文。如果你使用CoreGraphics作为备胎并打算显示渲染结果，你需要通过调整你的代码来弥补两个不同的默认坐标系的差异。更多信息请查看<a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW26" target="_blank" rel="external">Flipping the Default Coordinate System</a></p>
</blockquote>
<hr>
<h3 id="颜色和色彩空间"><a href="#颜色和色彩空间" class="headerlink" title="颜色和色彩空间"></a>颜色和色彩空间</h3><p>iOS在Quartz中支持全系列色彩空间，然而大多数应用只需要RGB色彩空间，因为iOS被设计用于运行在嵌入式硬件并且在屏幕上显示图像，RGB色彩空间是最合适的选择。</p>
<p>UIColor对象提供了便捷的方法指定RGB，HSB，灰阶色值。如果以该方式创建颜色，不需要指定色彩空间，因为UIColor自动为你定义了一个。</p>
<p>也可以使用CoreGraphics框架中的<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/c/func/CGContextSetRGBStrokeColor" target="_blank" rel="external"><code>CGContextSetRGBStrokeColor</code></a>和<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/c/func/CGContextSetRGBFillColor" target="_blank" rel="external"><code>CGContextSetRGBFillColor</code></a>来创建和设置颜色。尽管CoreGraphics包含了对(通过创建其它色彩空间以及自定义色彩空间来创建颜色)的支持，我们还是不推荐这么做。绘制的代码应该一直使用RGB颜色。</p>
<h2 id="使用Quartz和UIKit绘制"><a href="#使用Quartz和UIKit绘制" class="headerlink" title="使用Quartz和UIKit绘制"></a>使用Quartz和UIKit绘制</h2><p>Quartz在iOS中是原生绘画技术的通用名。CoreGraphics框架是Quartz的核心，也是绘制内容最基础的接口。该框架提供了数据类型和函数可以操作以下内容:</p>
<blockquote>
<ul>
<li>图形上下文</li>
<li>路径</li>
<li>图片和位图</li>
<li>透明层</li>
<li>颜色，图案颜色和色彩空间</li>
<li>渐变和阴影</li>
<li>字体</li>
<li>PDF内容</li>
</ul>
</blockquote>
<p>Quartz是专注于设计图像相关操作的类而UIKit正是基于Quartz的基础特性设计的。UIKit 图像类并不是作为全能的绘图工具而设计的-CoreGraphics已经做到了。相反的，CG为其它的UIKit类提供绘图支持。UIKit支持以下类和方法:<br>|class | description|<br>|:—|—:|<br>|UIImage|显示图片|<br>|UIColor|为设备颜色提供基础支持|<br>|UIFont|为需要的类提供字体信息|<br>|UIScreen|提供屏幕相关基础信息|<br>|UIBezierPath|允许应用绘制线条、弧线、椭圆和其它|</p>
<blockquote>
<ul>
<li>产生JPEG或PNG格式的UIImage对象的方法</li>
<li>绘制位图图形上下文的方法</li>
<li>向PDF图形上下文内绘制来得到PDF数据的方法</li>
<li>绘制矩形，裁剪绘制区域的方法</li>
<li>改变和获得当前图形上下文的方法</li>
</ul>
</blockquote>
<p>更多UIKit的方法和类，查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/index.html#//apple_ref/doc/uid/TP40006955" target="_blank" rel="external">UIKit Framework Reference</a>。更多关于CoreGraphics框架的类型和函数，查看<a href="https://developer.apple.com/library/ios/documentation/CoreGraphics/Reference/CoreGraphics_Framework/index.html#//apple_ref/doc/uid/TP40007127" target="_blank" rel="external">Core Graphics Framework Reference</a></p>
<h4 id="配置图形上下文"><a href="#配置图形上下文" class="headerlink" title="配置图形上下文"></a>配置图形上下文</h4><p>在调用<code>drawRect:</code>之前，view对象创建了一个图形上下文并设置为默认。该上下文只存在于<code>drawRect:</code>被调用的生命周期中。可以调用<code>UIGraphicsGetCurrentContext</code>来获得该图形上下文的指针。返回值是CGContextRef类型，将它传入CoreGraphics函数中修改当前图形状态。下表列举出不同方面的<code>图像状态</code>。完整函数请看<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_blank" rel="external">CGContext Reference</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dae4fea2jw1f4ftkjixg0j214b0mkdp6.jpg" alt=""></p>
<p>图形上下文拥有一个存放<code>图像状态</code>的栈。当Quartz创建了一个图形上下文，此时栈是空的。使用<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/c/func/CGContextSaveGState" target="_blank" rel="external"><code>CGContextSaveGState</code></a>将当前图形上下文状态压栈。随后，你可以通过更改<code>图像状态</code>来影响接下来的绘制操作，但不会影响栈中存储的操作。当你完成修改后，你可以调用<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/c/func/CGContextRestoreGState" target="_blank" rel="external"><code>CGContextRestoreGState</code></a>弹出栈内上下文来返回之前的上下文状态。这样弹栈和压栈是一种返回之前状态的快速方法并且无需解开每个状态变化。(Pushing and popping graphics states in this manner is a fast way to return to a previous state and eliminates the need to undo each state change individually)。但这也是唯一用来存储一些状态的方式，例如裁剪路径，返回初始设置。<br>更多关于图形上下文的信息和使用它们的配置环境，查看<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203" target="_blank" rel="external"><code>Graphics Contexts</code></a>,<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="external"><code>Quartz 2D Programming Guide</code></a></p>
<h4 id="创建并绘制路径"><a href="#创建并绘制路径" class="headerlink" title="创建并绘制路径"></a>创建并绘制路径</h4><p>路径是从一系列线条和贝塞尔曲线的基于向量的图形。UIKit拥有<code>UIRectFrame</code>和<code>UIRectFill</code>方法来绘制简单的路径，例如你view中的矩形。CoreGraphics 也提供了创造简单路径譬如矩形和椭圆的便捷函数。</p>
<p>对于复杂的路径，需要使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIBezierPath_class/index.html#//apple_ref/occ/cl/UIBezierPath" target="_blank" rel="external"><code>UIBezierPath</code></a>来自己创建路径，或使用CoreGraphics框架中操作<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPath/index.html#//apple_ref/c/tdef/CGPathRef" target="_blank" rel="external"><code>CGPathRef</code></a>的函数。尽管可以不用图形上下文来创建路径，路径中的点必须参考默认坐标系(ULO或LLO)，你仍旧需要使用图形上下文来渲染路径。</p>
<p>当绘制路径时，必须有当前上下文集。该图集可以是自定义view的(drawRect:中)上下文，位图上下文或者PDF上下文。坐标系决定了路径的渲染方式。<code>UIBezierPath</code>默认使用<code>ULO坐标系</code>，也就是说如果你的view被翻转使用了LLO坐标系，图形渲染结果可能会与预期不同。最好是指定点与用于渲染的图形上下文的当前坐标系原点绑定。</p>
<blockquote>
<ul>
<li>即使遵循该规则，弧线仍然需要更多额外的工作。如果使用Core Graphics函数通过在ULO坐标系中定位点来创建路径，随后在UIKit的view中渲染路径，弧线的方向是不同的。查看更多相关信息<a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW8" target="_blank" rel="external">Side Effects of Drawing with Different Coordinate Systems</a></li>
</ul>
</blockquote>
<p>在iOS中创建路径，更推荐使用<code>UIBezierPath</code>来代替<code>CGPath</code>方法，除非需要使用CoreGraphics的特性，例如在路径中添加椭圆。更多创建和渲染路径的方法，点击<a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html#//apple_ref/doc/uid/TP40010156-CH11-SW1" target="_blank" rel="external"><code>Drawing Shapes Using Bézier Paths</code></a></p>
<p>更多关于使用UIBezierPath绘制路径的方法，查看<a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html#//apple_ref/doc/uid/TP40010156-CH11-SW1" target="_blank" rel="external"><code>Drawing Shapes Using Bézier Paths</code></a>。更多关于使用CoreGraphics绘制路径，例如如何指定点到复杂路径中，查看Quartz 2D中的<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211" target="_blank" rel="external"><code>Paths</code></a>。更多关于创建路径的信息<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_blank" rel="external"><code>CGContext Reference</code></a>和<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPath/index.html#//apple_ref/doc/uid/TP30000959" target="_blank" rel="external"><code>CGPath Reference</code></a></p>
<h4 id="创建图案，渐变和阴影"><a href="#创建图案，渐变和阴影" class="headerlink" title="创建图案，渐变和阴影"></a>创建图案，渐变和阴影</h4><p>CoreGraphics框架包含了创建图案，渐变，阴影的功能。你可以使用这些来创建非黑白色并且使用使用它们填充你创建的路径。图案是从重复的图片或内容中创建出来的。渐变和阴影可提供不同的方案来创建颜色到颜色的平滑的过度。</p>
<p>创建，使用图案，渐变和阴影的更多细节，查看<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="external"><code>Quartz 2D Programming Guide</code></a></p>
<h4 id="自定义坐标空间"><a href="#自定义坐标空间" class="headerlink" title="自定义坐标空间"></a>自定义坐标空间</h4><p>UIKit默认直接创建用于映射point到px的当前转换矩阵。尽管在绘制中完全不需要修改这个矩阵，但有时候更改该矩阵会更方便。</p>
<p>当view第一次调用<code>drawRect:</code>时，CTM(当前转换矩阵)已经配置好所以坐标系原点与view的原点相匹配，X轴向右为正，Y轴向下为正。然而你可以通过添加缩放，旋转和转换因子来改变CTM从而改变大小，方向，并且默认坐标系的位置与底层的view或window有关。</p>
<h5 id="使用坐标变换来提升绘制表现"><a href="#使用坐标变换来提升绘制表现" class="headerlink" title="使用坐标变换来提升绘制表现"></a>使用坐标变换来提升绘制表现</h5><p>修改CTM是绘制内容的一个基础技巧，因为它允许你重用路径，这样可能会减少绘制时的计算量。举个栗子，如果你想在(20,20)画一个正方形，需要创建一个路径移动到(20,20)随后绘制必要的线条。然而，如果你又想把正方形移动到(10,10)，可能需要重新创建新起点的路径。因为创建路径实在是一个消耗较大的操作，它会更倾向于创建一个原点在(0,0)的正方形，然后修改CTM使得正方形绘制在正确区域。</p>
<p>在CoreGraphics框架中有两种方式可以修改CTM。可以使用<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_blank" rel="external"><code>CGContext Reference</code></a>中定义的CTM操作函数立刻修改CTM。也可以创建一个<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGAffineTransform/index.html#//apple_ref/c/tdef/CGAffineTransform" target="_blank" rel="external"><code>CGAffineTransform</code></a>结构体，应用各种你想使用的变换，然后将这个变换应用到CTM中。使用仿射变换可以让你的组(group)变换随后立刻应用到CTM上。你也可以评估，倒置仿射变换并用它们来修正代码中的点，大小和矩形值。更多仿射变换信息<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="external"><code>Quartz 2D Programming Guide</code></a> 和 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGAffineTransform/index.html#//apple_ref/doc/uid/TP30000946" target="_blank" rel="external"><code>CGAffineTransform Reference</code></a></p>
<h5 id="翻转默认坐标系"><a href="#翻转默认坐标系" class="headerlink" title="翻转默认坐标系"></a>翻转默认坐标系</h5><p>Flipping in UIKit drawing modifies the backing CALayer to align a drawing environment having a LLO coordinate system with the default coordinate system of UIKit。如果仅使用UIKit来绘制，就不需要翻转CTM。然而如果是CoreGraphics和UIKit调用的图片I/O 函数混合使用，这时候翻转就派上用场了。</p>
<p>如果你调用CoreGraphics绘制了图片或PDF文档，对象会在view的上下文中渲染的乱七八糟。你必须翻转CTM让图片和文稿正确显示。</p>
<p>翻转绘制在CoreGraphics上下文中的对象以便于在UIKit的view中正确显示，修改CTM一共分两步。将原点变换到绘制区域的左上角，随后进行尺寸变换，修改y-coordinate为-1，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGContextSaveGState(graphicsContext);</span><br><span class="line">CGContextTranslateCTM(graphicsContext, 0.0, imageHeight);</span><br><span class="line">CGContextScaleCTM(graphicsContext, 1.0, -1.0);</span><br><span class="line">CGContextDrawImage(graphicsContext, image, CGRectMake(0, 0, imageWidth, imageHeight));</span><br><span class="line">CGContextRestoreGState(graphicsContext);</span><br></pre></td></tr></table></figure></p>
<p>如果通过CoreGraphics image对象初始化了一个UIImage对象，UIKit自动帮你翻转。每一个UIImage对象是由<code>CGImageRef</code>类型构成的。可以通过CGImage属性获取CoreGraphics对象并且做一些操作。当完成后，从修改后的<code>CGImageRef</code>对象中可以重建UIImage对象</p>
<blockquote>
<p>可用CoreGraphics方法<code>CGContextDrawImage</code>来绘制渲染目标。它有两个参数，第一个是图形上下文，第二个是矩形区域(既是图片的大小同时也是绘制表面的位置，比如View)。当使用该方法时，如果不调整当前坐标系为LLO，图片在UIKit的view中会颠倒。另外，矩形的原点是相对于函数调用时刻当前坐标原点。</p>
</blockquote>
<h5 id="不同坐标系绘制的副作用"><a href="#不同坐标系绘制的副作用" class="headerlink" title="不同坐标系绘制的副作用"></a>不同坐标系绘制的副作用</h5><p>假设使用LLO坐标系调用<code>CGContextAddArc</code>和<code>CGPathAddArc</code>绘制路径，需要翻转CTM来在UIKit的view中正确渲染弧线。如果使用如果在ULO坐标系中渲染到UIKit的view上，你会发现弧线会和初始的不一样。当使用<code>UIBezierPath</code>绘制弧线时，弧线的终点与LLO相反，例如，一个向下的箭头现在向上，并且顺逆相反。你必须将CoreGraphics中绘制的弧线改成基于ULO坐标系；这些函数的<code>startAngle</code>和<code>endAngle</code>控制了弧线方向。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/flipped_coordinates-1_2x.png" alt=""></p>
<p>(通过调用<code>CGContextRotateCTM</code>)可以旋转对象，你会观察出它们完全是镜像效果。如果旋转一个ULO坐标系的CoreGraphics中的对象，它的方向是和UIKit中的旋转方向相反。你必须为在代码中为他们设置不同的旋转方向(<code>CGContextRotateCTM</code>)，反转<code>angle</code>的参数</p>
<h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>盈盈的方向是对象指定偏移量，也就是说偏移量在绘制框架中是一个惯例。在UIKit中，xy轴的正向偏移量似的阴影向下、向右。在CoreGraphics中，则是向上、向右。翻转CTM使得默认坐标系对齐不会影响对象的阴影，阴影也不会正确的追踪对象。如果想正确的追踪，必须修改当前坐标系的偏移量。</p>
<blockquote>
<p>在iOS3.2以上，CoreGraphics和UIKit拥有共同的阴影方向：正向偏移量使得阴影向下、向右。</p>
</blockquote>
<hr>
<h3 id="应用CoreAnimation效果"><a href="#应用CoreAnimation效果" class="headerlink" title="应用CoreAnimation效果"></a>应用CoreAnimation效果</h3><p>CoreAnimation是OC中提供快速便捷创造流动，实时的动画。CoreAnimation本身不是一个绘制技术，也就是说它不提供创建图形，图片或其他内容。相反的，它是一个操纵并展示由其他技术创建的内容。</p>
<p>在很多案例中，付出一点就可以从CoreAnimation中获得好处。例如，UIView的很多属性(包括view的frame,center,color，opacity)可以配置在值变化时触发动画。你需要做一些事情来让UIkit知道你想执行这些动画，但它们却是自动为你运行的。更多关于如何触发view内置动画，查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/doc/uid/TP40006816-CH3-SW62" target="_blank" rel="external"><code>Animating Views</code></a>和<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/doc/uid/TP40006816" target="_blank" rel="external"><code>UIView Class Reference</code></a></p>
<p>如果想查看更多高级动画教程，查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="external"><code>Core Animation Programming Guide</code></a></p>
<h4 id="关于Layer"><a href="#关于Layer" class="headerlink" title="关于Layer"></a>关于Layer</h4><p>CoreAnimation的核心技术就是layer对象。layer是和view相似的轻量级对象，但它们实际上是一个模型对象。封装了几何、时间、视觉属性等你想展示的内容。</p>
<blockquote>
<ul>
<li>将CGImageRef赋值到layer对象的contents属性</li>
<li>给layer赋值一个delegate并处理绘制</li>
<li>可以子类化CALayer并重载其中的显示方法。</li>
</ul>
</blockquote>
<p>Layer相关信息请看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="external"><code>Core Animation Programming Guide</code></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://jzy476731162.github.io/2016/05/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
